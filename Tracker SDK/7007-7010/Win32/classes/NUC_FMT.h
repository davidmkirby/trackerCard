///////////////////////////////////////////////////////////////////////////////
// NUC_FMT.H
//
// Message structure definitions to support camera calibration/normalization
// for the following products:
// * Model 7005 and 7006 VME Video Trackers
//
#include "MSG_FMT.H"

/*******************************************************************************
* Copyright (c) 2007 Electro-Optical Imaging, Inc. All Rights Reserved
*
* Electro-Optical Imaging, Inc. (E-O Imaging) licenses this software under 
* specific terms and conditions.  Use of any of the software or derivatives
* thereof in any product without a Electro-Optical Imaging, Inc. tracker is 
* strictly prohibited.
*
* Electro-Optical Imaging, Inc. provides this software AS IS, WITHOUT ANY 
* WARRANTY, EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY WARRANTY
* OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  E-O Imaging makes
* no guarantee or representations regarding the use of, or the results of the
* use of, the software and documentation in terms of correctness, accuracy,
* reliability, currentness, or otherwise; and you rely on the software,
* documentation and results solely at your own risk.
*
* IN NO EVENT SHALL E-O IMAGING BE LIABLE FOR ANY LOSS OF USE, LOSS OF BUSINESS,
* LOSS OF PROFITS, INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES
* OF ANY KIND.  IN NO EVENT SHALL E-O IMAGING'S TOTAL LIABILITY EXCEED THE SUM
* PAID TO E-O IMAGING FOR THE PRODUCT LICENSED HEREUNDER.
*
******************************************************************************/

#ifndef __NUC_FMT_H__
#define __NUC_FMT_H__

#pragma pack(push, 1)	// pack all messages with single byte alignment

// data types
#ifndef ULONG
typedef unsigned long	ULONG;
#endif

#ifndef USHORT
typedef unsigned short	USHORT;
#endif

#ifndef UCHAR
typedef unsigned char	UCHAR;
#endif


/*******************************************************************************
   FLIR Systems uses three files to calibrate their thermal cameras:
   1. A gain file (*.SCG)
   2. An offset file (*.SCO)
   3. A bad pixel file (*.SBP)

   Our implementation is based on the FLIR calibration implementation and
   sending the files which are generated by their software to the tracker.
   When using the camera calibration, all three files must be sent to the
   tracker in order for it to function.  The tables are not saved in
   nonvolatile memory by the tracker.  All three must be sent after tracker
   power up.

   DOWNLOADING TO THE TRAKCER:
   See the MSG_FMT.H file for structures.
   When sending the DL_CODE_RECEIVE_MSG (type 50) message to the tracker, the
   first data block's payload contains the number of pixel and lines in the file
   (ie-the image resolution).  The rest of the payloads contain a byte count
   followed by the data.
*/


/*******************************************************************************
   DL_CODE_RECEIVE_MSG payload structures
   This is how the data is stored in the data[DL_CODE_SIZE] payload

   NOTE: THE ASSUMPTION IS THAT DL_CODE_SIZE EQUALS 80.
*/
typedef struct
{
	USHORT	Version;			// Tracker NUC version (currently = 1)
	USHORT	NumberOfPixels;
	USHORT	NumberOfLines;
//	UCHAR	spare[DL_CODE_SIZE - (3*sizeof(USHORT))];

} NUC_FIRST_PACKET;

#define NUC_GAIN_ELEMENTS		19
typedef struct
{
	UCHAR	count;			// Number of ULONGs in this payload
	ULONG	data[NUC_GAIN_ELEMENTS];
//	UCHAR	spare[DL_CODE_SIZE - (1 - (NUC_GAIN_ELEMENTS*4))];

} NUC_GAIN_PACKET;

#define NUC_OFFSET_ELEMENTS		39
typedef struct
{
	UCHAR	count;			// Number of shorts in this payload
	short	data[NUC_OFFSET_ELEMENTS];
//	UCHAR	spare[DL_CODE_SIZE - (1 - (NUC_OFFSET_ELEMENTS*2))];

} NUC_OFFSET_PACKET;

typedef struct
{
	UCHAR	count;			// Number of UCHARs in this payload
	UCHAR	data[DL_CODE_SIZE-1];

} NUC_BADPIXEL_PACKET;


/*******************************************************************************
   Binary file header
   All three file types have the same header.
*/

typedef struct
{
	UCHAR	Version;			// File version (2 or 3 ONLY)
	UCHAR	FileType;			// File type
								//   0=gain, 1=offset, 2=bad pixel
	USHORT	NumX;				// Pixels per line
	USHORT	NumY;				// Lines per frame
	USHORT	Superframe;			// Superframe number = 0,1,2,3.  If non-superframe then 0.
	char	Irig[18];			// IRIG time string as ddd:hh:mm:ss.mmmm (NULL terminated)
	UCHAR	CalType;			// Calibration type
								//   0=basic 1 point, 1=basic 2 point, 2=update offset, 3=defaults
	UCHAR	NormAlg;			// Normalization algrithm type
								//   1=BKC version 1
	UCHAR	BPHandling;			// Bad pixel handling algorithm type
								//   1=Basic pixel substitution
	USHORT	NumAvg;				// Number of frames averaged
	float	BPTolerance;		// Bad pixel tolerance
	char	OriginalName[128];	// Original file name (NULL terminated)
	char	AverageFile[128];	// Average data file name (NULL terminated)
	char	PerviousFile[128];	// Previous file this one replaces (NULL terminated)

} NUC_FILE_HEADER;


/*******************************************************************************
   Gain file download

   Gain values are stored in the file as an array of floats (float[X*Y])
   The values in the file range from 0.5 to 1.99997

   Before sending to the tracker, the gain values must be converted to a
   32-bit unsigned integer using the following equation:

   NUC gain = file gain * 2^17
*/

/*******************************************************************************
   Offset file download

   Gain values are stored in the file as an array of shorts (short[X*Y])
   The values in the file range from ±16384.

   The values are sent to the tracker as 16-bit signed integers.
*/

/*******************************************************************************
   Bad pixel file download

   Bad pixel values are stored in the file as an array of bytes (unsigned char[X*Y])
   where a value of 0=good pixel and 1=bad pixel.

   The values are sent to the tracker as 8-bit unsigned integers.
*/


/****************************************************************************/
#pragma pack(pop)	// reset to default packing

#endif //__NUC_FMT_H__
